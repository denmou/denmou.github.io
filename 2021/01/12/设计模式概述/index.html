<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>设计模式概述 - Denmou&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Denmou&#039;s Blog"><meta name="msapplication-TileImage" content="/static/favicon.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Denmou&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="什么是设计模式 设计模式是一套被反复使用、经过分类编目、代码设计经验的总结 其描述了软件开发过程中一些不断重复发生的问题，以及该问题的解决方案 是为了解决特定问题的一系列思路，具有一定普遍性，可反复使用"><meta property="og:type" content="blog"><meta property="og:title" content="设计模式概述"><meta property="og:url" content="http://denmou.github.io/2021/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"><meta property="og:site_name" content="Denmou&#039;s Blog"><meta property="og:description" content="什么是设计模式 设计模式是一套被反复使用、经过分类编目、代码设计经验的总结 其描述了软件开发过程中一些不断重复发生的问题，以及该问题的解决方案 是为了解决特定问题的一系列思路，具有一定普遍性，可反复使用"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://denmou.github.io/gallery/cover/fly.jpg"><meta property="article:published_time" content="2021-01-12T07:46:35.000Z"><meta property="article:modified_time" content="2023-02-08T06:49:33.552Z"><meta property="article:author" content="denmou"><meta property="article:tag" content="设计模式"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/cover/fly.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://denmou.github.io/2021/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"},"headline":"Denmou's Blog","image":["http://denmou.github.io/gallery/cover/fly.jpg"],"datePublished":"2021-01-12T07:46:35.000Z","dateModified":"2023-02-08T06:49:33.552Z","author":{"@type":"Person","name":"Denmou"},"description":"什么是设计模式 设计模式是一套被反复使用、经过分类编目、代码设计经验的总结 其描述了软件开发过程中一些不断重复发生的问题，以及该问题的解决方案 是为了解决特定问题的一系列思路，具有一定普遍性，可反复使用"}</script><link rel="canonical" href="http://denmou.github.io/2021/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"><link rel="alternate" href="/atom.xml" title="Denmou&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/static/favicon.jpg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/static/logo.svg" alt="Denmou&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="https://github.com/denmou"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/cover/fly.jpg" alt="设计模式概述"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-12T07:46:35.000Z" title="2021-01-12T07:46:35.000Z">2021-01-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-08T06:49:33.552Z" title="2023-02-08T06:49:33.552Z">2023-02-08</time></span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span><span class="level-item">18 minutes read (About 2747 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">设计模式概述</h1><div class="content"><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a><strong>什么是设计模式</strong></h2><ul>
<li>设计模式是一套被反复使用、经过分类编目、代码设计经验的总结</li>
<li>其描述了软件开发过程中一些不断重复发生的问题，以及该问题的解决方案</li>
<li>是为了解决特定问题的一系列思路，具有一定普遍性，可反复使用<a id="more"></a>

</li>
</ul>
<h3 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a><strong>出现背景</strong></h3><ul>
<li>1977年，建筑师 <strong><em>克里斯托夫·亚历山大（Christopher Alexander）</em></strong> 在其著作 <strong>《建筑模式语言：城镇、建筑、构造（A Pattern Language：Towns Building Construction）》</strong> 中所提出的253种关于城镇、邻里、住宅、花园和房间等进行设计的基本模式。</li>
<li>1979年，在其另一部著作 <strong>《建筑的永恒之道（The Timeless way of building）》</strong> 中进一步强化了设计模式思想。</li>
<li>1987年， <strong><em>肯特·贝克（Kent Beck）</em></strong> 和 <strong><em>沃德·坎宁安（Ward Cunningham）</em></strong> 首次将模式思想应用到Smalltalk中图形用户接口生成中，但未引起关注</li>
<li>1990年，软件工程届开始讨论设计模式相关话题，并展开多次研讨会</li>
<li>1995年， <strong><em>艾瑞克·伽马（Erich Gamma）</em></strong> 、 <strong><em>理查德·海尔姆（Richard Helm）</em></strong> 、 <strong><em>拉尔夫·约翰森（Ralph Johnson）</em></strong> 、 <strong><em>约翰·威利斯迪斯（John Vlissides）</em></strong> 等4位作者 <strong><em>（Gang of Four，GoF）</em></strong> 合作出版了 <strong>《设计模式：可复用面向对象软件基础（Design Patterns：Elements of Reusable Object-Oriented Software）》</strong> ，其中收录了23种设计模式，是软件设计模式的一大突破。直至今日，狭义设计模式所指的仍是上述23种设计模式</li>
</ul>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><ul>
<li>提高代码的可重用性、可读性、可靠性</li>
<li>提示思维能力、编程能力、设计能力</li>
<li>代码结构标准化、提升开发效率、缩短开发周期</li>
<li>代码可重用性高、可读性好、可靠性高、灵活性好、可维护性强</li>
</ul>
<h3 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a><strong>基本要素</strong></h3><ul>
<li>模式名称<ul>
<li>通常用一两个词来描述，根据模式的问题、特点、解决方案、功能和效果来命名</li>
</ul>
</li>
<li>问题<ul>
<li>描述使用该模式的应用环境，解释设计问题和问题存在的前因后果，以及必须满足一系列先觉条件</li>
</ul>
</li>
<li>解决方案<ul>
<li>包括设计的组成部分、他们之间的相互关系以及各自的职责和协作方式。</li>
<li>解决方案不描述一个特定而具体的设计货实现，而是提供设计问题的抽象描述及怎样用一个具有一般意义的元素（类或对象）组合来解决问题</li>
</ul>
</li>
<li>效果<ul>
<li>描述该模式的应用效果及使用该模式所需要权衡的问题，即该模式的优缺点。</li>
<li>主要是对空间与时间的权衡，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题</li>
<li>显示的列出这些效果有主意理解与评价该设计模式</li>
</ul>
</li>
</ul>
<h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a><strong>七大原则</strong></h2><h3 id="开闭原则（Open-Close-Principle，OCP）"><a href="#开闭原则（Open-Close-Principle，OCP）" class="headerlink" title="开闭原则（Open Close Principle，OCP）"></a><strong>开闭原则（Open Close Principle，OCP）</strong></h3><p>1988年， <strong><em>勃兰特·梅耶（Bertrand Meyer）</em></strong> 在其著作 <strong>《面向对象软件构造（Object Oriented Software Construction）》</strong> 中提出:</p>
<blockquote>
<p>软件应对拓展开放，对修改关闭<br>Software entities should be open for extension, but closed for modification</p>
</blockquote>
<ul>
<li>作用<ul>
<li>软件测试方面仅需测试拓展的代码，原代码仍能正常运行</li>
<li>提高代码的可复用性，代码粒度越小，复用性则越高</li>
<li>提高软件的可维护性，准守开闭原则的软件具有较高的稳定性和延续性，易于拓展和维护</li>
</ul>
</li>
<li>实现<ul>
<li>通过接口或抽象类为软件定义一个相对稳定的抽象层，将相同的可变因素封装在相同的实现类中</li>
</ul>
</li>
</ul>
<h3 id="里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle，LSP）"></a><strong>里氏替换原则（Liskov Substitution Principle，LSP）</strong></h3><p>1987年， <strong><em>里斯科夫（Liskov）</em></strong> 女士在 <strong>面向对象的技术高峰会议（OOPSLA）</strong> 上发表的一篇文章 <strong>《数据抽象和层次（Data Abstraction and Hierarchy）》</strong> 中提出:</p>
<blockquote>
<p>继承必须确保超类所拥有的性质在子类中仍然成立。<br>Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.</p>
</blockquote>
<ul>
<li>作用<ul>
<li>对开闭原则的补充</li>
<li>确保动作的正确性，即类的拓展不会给已有的系统引入新的错误，提高系统的稳定性</li>
</ul>
</li>
<li>实现<ul>
<li>子类继承父类时，除添加新功能实现拓展方法外，不能改变父类原油功能，即应尽量不重写（或禁止重写）父类方式</li>
</ul>
</li>
</ul>
<h3 id="依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a href="#依赖倒置原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle，DIP）"></a><strong>依赖倒置原则（Dependence Inversion Principle，DIP）</strong></h3><p>1996年，Object Mentor 公司总裁 <strong><em>罗伯特·C.马丁（Rebert C.Martin）</em></strong> 在 <strong>C++ Report</strong> 发表文章，对其作出定义:</p>
<blockquote>
<p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。<br>High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</p>
</blockquote>
<p>即：面向接口（抽象）编程</p>
<ul>
<li>作用<ul>
<li>实现开闭原则的重要途径之一</li>
<li>降低了模块之间的耦合</li>
<li>提高系统稳定性</li>
<li>减少并行开发引发的风险</li>
<li>提高代码可读性和可维护性</li>
</ul>
</li>
<li>实现<ul>
<li>通过面向接口编程降低耦合性</li>
<li>每个类尽量提供接口和抽象类，或二者都提供</li>
<li>变量的声明应尽量是接口或抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>使用继承时尽量准守里氏替换原则</li>
</ul>
</li>
</ul>
<h3 id="单一职责原则（Dependence-Inversion-Principle，DIP）"><a href="#单一职责原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="单一职责原则（Dependence Inversion Principle，DIP）"></a><strong>单一职责原则（Dependence Inversion Principle，DIP）</strong></h3><p><strong><em>罗伯特·C.马丁（Rebert C.Martin）</em></strong> 在 <strong>《敏捷软件开发：原则、模式和实践》</strong> 中提出:</p>
<blockquote>
<p>一个类应该有且仅有一个引起其变化的原因，否则类应该被拆分。<br>There should never be more then one reason for a class to change.</p>
</blockquote>
<ul>
<li>作用<ul>
<li>控制类的粒度，解耦对象、提高内聚</li>
<li>降低类的复杂度</li>
<li>提高类的可读性</li>
<li>提高系统的可维护性</li>
<li>由变更而引起的风险降低</li>
</ul>
</li>
<li>实现<ul>
<li>（简单但难运用）需要设计人员发现类的不同职责并将其分离，再封装到不同类或模块中</li>
</ul>
</li>
</ul>
<h3 id="接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle，ISP）"></a><strong>接口隔离原则（Interface Segregation Principle，ISP）</strong></h3><p>2002年， <strong><em>罗伯特·C.马丁（Rebert C.Martin）</em></strong> 给其定义:</p>
<blockquote>
<p>客户端不应被迫依赖于它不使用的方法。<br>Clients should not be forced to depend on methods they do not sure.</p>
</blockquote>
<p>该原则还有另外一个定义：</p>
<blockquote>
<p>一个类对另一个类的依赖应该建立在最小接口上。<br>The dependency of one class to another one should depend on the smallest possible interface.</p>
</blockquote>
<p>总结为：应为各个类建立专用的接口，不应建立一个庞大的接口供所有的依赖类调用</p>
<ul>
<li>作用<ul>
<li>约束接口，降低类对接口的依赖性</li>
<li>将庞大接口划分为多个粒度小的接口，预防外来变更的扩散，提高系统的灵活性和可维护性</li>
<li>提高系统内聚性，降低耦合性</li>
<li>接口粒度大小合理情况下可以保证系统的稳定性；但若粒度过小，造成接口过多将使设计复杂化；相对的粒度过大，灵活性降低，无法提供定制服务，给项目留下风险隐患</li>
<li>使用多个专门的接口可以体现对象的层次，可以通过接口的继承，实现对总接口的定义</li>
<li>减少项目中的冗余代码，避免派生类去实现无用的接口方法</li>
</ul>
</li>
<li>实现<ul>
<li>接口尽量小，但有限度，一个接口仅服务于一个子模块或业务逻辑</li>
<li>为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法</li>
<li>根据业务逻辑、环境因素进行接口拆分</li>
<li>使用最少的接口完成最多的事情</li>
</ul>
</li>
</ul>
<h3 id="迪米特法则（Law-of-Demeter，LoD）"><a href="#迪米特法则（Law-of-Demeter，LoD）" class="headerlink" title="迪米特法则（Law of Demeter，LoD）"></a><strong>迪米特法则（Law of Demeter，LoD）</strong></h3><p>又称为 <strong>最少知识原则（Least Knowledge Principle，LKP）</strong> ，1987年，诞生于 <strong>美国东北大学（Northeastern University）</strong> 的 <strong>迪米特（Demeter）</strong> 研究项目，由 <strong><em>伊恩·荷兰（Lan Holland）</em></strong> 提出，被UML创始者之一的 <strong><em>布奇（Booch）</em></strong> 普及，后来因 <strong>《程序员的修炼之道（The Pragmatic programmer）》</strong> 提及而广为人知，其定义为：</p>
<blockquote>
<p>只与你的直接朋友交谈，不和陌生人说话。<br>Talk only to your immediate friends and not to strangers.</p>
</blockquote>
<p>可理解为：如果两个模块间无需直接通信，那么就不应当发生直接调用，可有第三方模块转发，以降低耦合性，提高独立性</p>
<ul>
<li>作用<ul>
<li>限制了软件实体间通信的宽度和深度</li>
<li>降低耦合性，提高独立性</li>
<li>提高类的可复用性和系统的拓展性</li>
</ul>
</li>
<li>实现<ul>
<li>依赖者只依赖应该依赖的对象</li>
<li>提供者只暴露应该暴露的方法</li>
<li>类的划分上，应创建弱耦合类</li>
<li>类结构上，降低类成员的访问权限</li>
<li>类设计上，优先考虑一个类设置成一个不变类</li>
<li>对类的引用上，因对其他对象的引用次数降至最低</li>
<li>不暴露类的属性，提供访问器</li>
<li>谨慎使用序列化（Serializable）功能</li>
</ul>
</li>
</ul>
<h3 id="合成复用原则（Composite-Reuse-Principle，CRP）"><a href="#合成复用原则（Composite-Reuse-Principle，CRP）" class="headerlink" title="合成复用原则（Composite Reuse Principle，CRP）"></a><strong>合成复用原则（Composite Reuse Principle，CRP）</strong></h3><p>又叫 <strong>组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）</strong> ，其要求在软件复用时，优先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现，使用继承关系需要严格遵守里氏替换原则，二者相辅相成，皆为开闭原则的具体实现规范</p>
<ul>
<li>作用（继承复用的缺陷<ul>
<li>组合/聚合维持类的封装性，又称为黑箱复用</li>
<li>新旧类耦合度低，该复用方式依赖较低，反问成分对象的唯一方法是通过成分对象的接口</li>
<li>灵活性高，可动态引用成分对象类型相同的对象</li>
</ul>
</li>
<li>实现<ul>
<li>通过将已有对象纳入新对象中，作为成员对象来实现。新对象可以调用成员对象的功能，从而达到复用的目的</li>
</ul>
</li>
</ul>
<hr>
<p>参考文档：<a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">http://c.biancheng.net/design_pattern/</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>设计模式概述</p><p><a href="http://denmou.github.io/2021/01/12/设计模式概述/">http://denmou.github.io/2021/01/12/设计模式概述/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Denmou</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-01-12</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-02-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5ffc509063ffa200121a47b6&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/16/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">23种设计模式</span></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><script src="https://utteranc.es/client.js" repo="denmou/denmou.github.io" issue-term="pathname" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么是设计模式"><span class="level-left"><span class="level-item">什么是设计模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#出现背景"><span class="level-left"><span class="level-item">出现背景</span></span></a></li><li><a class="level is-mobile" href="#目的"><span class="level-left"><span class="level-item">目的</span></span></a></li><li><a class="level is-mobile" href="#基本要素"><span class="level-left"><span class="level-item">基本要素</span></span></a></li></ul></li><li><a class="level is-mobile" href="#七大原则"><span class="level-left"><span class="level-item">七大原则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#开闭原则（Open-Close-Principle，OCP）"><span class="level-left"><span class="level-item">开闭原则（Open Close Principle，OCP）</span></span></a></li><li><a class="level is-mobile" href="#里氏替换原则（Liskov-Substitution-Principle，LSP）"><span class="level-left"><span class="level-item">里氏替换原则（Liskov Substitution Principle，LSP）</span></span></a></li><li><a class="level is-mobile" href="#依赖倒置原则（Dependence-Inversion-Principle，DIP）"><span class="level-left"><span class="level-item">依赖倒置原则（Dependence Inversion Principle，DIP）</span></span></a></li><li><a class="level is-mobile" href="#单一职责原则（Dependence-Inversion-Principle，DIP）"><span class="level-left"><span class="level-item">单一职责原则（Dependence Inversion Principle，DIP）</span></span></a></li><li><a class="level is-mobile" href="#接口隔离原则（Interface-Segregation-Principle，ISP）"><span class="level-left"><span class="level-item">接口隔离原则（Interface Segregation Principle，ISP）</span></span></a></li><li><a class="level is-mobile" href="#迪米特法则（Law-of-Demeter，LoD）"><span class="level-left"><span class="level-item">迪米特法则（Law of Demeter，LoD）</span></span></a></li><li><a class="level is-mobile" href="#合成复用原则（Composite-Reuse-Principle，CRP）"><span class="level-left"><span class="level-item">合成复用原则（Composite Reuse Principle，CRP）</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">异步处理, 分布式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2023/02/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E5%AF%B9/"><img src="/gallery/thumbnails/flying.jpg" alt="Kafka"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-07T02:52:53.000Z">2023-02-07</time></p><p class="title"><a href="/2023/02/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E5%AF%B9/">Kafka</a></p><p class="categories"><a href="/categories/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E5%88%86%E5%B8%83%E5%BC%8F/">异步处理, 分布式</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/01/16/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img src="/gallery/thumbnails/flying.jpg" alt="23种设计模式"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-01-16T09:52:53.000Z">2021-01-16</time></p><p class="title"><a href="/2021/01/16/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">23种设计模式</a></p><p class="categories"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"><img src="/gallery/thumbnails/fly.jpg" alt="设计模式概述"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-01-12T07:46:35.000Z">2021-01-12</time></p><p class="title"><a href="/2021/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/">设计模式概述</a></p><p class="categories"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Apache/"><span class="tag">Apache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">消息中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/static/logo.svg" alt="Denmou&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Denmou</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/denmou"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>