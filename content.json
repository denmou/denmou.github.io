{"pages":[{"title":"","text":"/* eslint-disable node/no-unsupported-features/node-builtins */ (function($, moment, ClipboardJS, config) { $('.article img:not(\".not-gallery-item\")').each(function() { // wrap images with link and add caption if possible if ($(this).parent('a').length === 0) { $(this).wrap(''); if (this.alt) { $(this).after('' + this.alt + ''); } } }); if (typeof $.fn.lightGallery === 'function') { $('.article').lightGallery({ selector: '.gallery-item' }); } if (typeof $.fn.justifiedGallery === 'function') { if ($('.justified-gallery > p > .gallery-item').length) { $('.justified-gallery > p > .gallery-item').unwrap(); } $('.justified-gallery').justifiedGallery(); } $('.article > .content > table').each(function() { if ($(this).width() > $(this).parent().width()) { $(this).wrap(''); } }); function adjustNavbar() { const navbarWidth = $('.navbar-main .navbar-start').outerWidth() + $('.navbar-main .navbar-end').outerWidth(); if ($(document).outerWidth() < navbarWidth) { $('.navbar-main .navbar-menu').addClass('justify-content-start'); } else { $('.navbar-main .navbar-menu').removeClass('justify-content-start'); } } adjustNavbar(); $(window).resize(adjustNavbar); function toggleFold(codeBlock, isFolded) { const $toggle = $(codeBlock).find('.fold i'); !isFolded ? $(codeBlock).removeClass('folded') : $(codeBlock).addClass('folded'); !isFolded ? $toggle.removeClass('fa-angle-right') : $toggle.removeClass('fa-angle-down'); !isFolded ? $toggle.addClass('fa-angle-down') : $toggle.addClass('fa-angle-right'); } function createFoldButton(fold) { return '' + (fold === 'unfolded' ? '' : '') + ''; } $('figure.highlight table').wrap(''); if (typeof config !== 'undefined' && typeof config.article !== 'undefined' && typeof config.article.highlight !== 'undefined') { $('figure.highlight').addClass('hljs'); $('figure.highlight .code .line span').each(function() { const classes = $(this).attr('class').split(/\\s+/); if (classes.length === 1) { $(this).addClass('hljs-' + classes[0]); $(this).removeClass(classes[0]); } }); const clipboard = config.article.highlight.clipboard; const fold = config.article.highlight.fold.trim(); $('figure.highlight').each(function() { if ($(this).find('figcaption').length) { $(this).find('figcaption').addClass('level is-mobile'); $(this).find('figcaption').append(''); $(this).find('figcaption').append(''); $(this).find('figcaption div.level-left').append($(this).find('figcaption').find('span')); $(this).find('figcaption div.level-right').append($(this).find('figcaption').find('a')); } else { if (clipboard || fold) { $(this).prepend(''); } } }); if (typeof ClipboardJS !== 'undefined' && clipboard) { $('figure.highlight').each(function() { const id = 'code-' + Date.now() + (Math.random() * 1000 | 0); const button = ''; $(this).attr('id', id); $(this).find('figcaption div.level-right').append(button); }); new ClipboardJS('.highlight .copy'); // eslint-disable-line no-new } if (fold) { $('figure.highlight').each(function() { if ($(this).find('figcaption').find('span').length > 0) { const span = $(this).find('figcaption').find('span'); if (span[0].innerText.indexOf('>folded') > -1) { span[0].innerText = span[0].innerText.replace('>folded', ''); $(this).find('figcaption div.level-left').prepend(createFoldButton('folded')); toggleFold(this, true); return; } } $(this).find('figcaption div.level-left').prepend(createFoldButton(fold)); toggleFold(this, fold === 'folded'); }); $('figure.highlight figcaption .fold').click(function() { const $code = $(this).closest('figure.highlight'); toggleFold($code.eq(0), !$code.hasClass('folded')); }); } } const $toc = $('#toc'); if ($toc.length > 0) { const $mask = $(''); $mask.attr('id', 'toc-mask'); $('body').append($mask); function toggleToc() { // eslint-disable-line no-inner-declarations $toc.toggleClass('is-active'); $mask.toggleClass('is-active'); } $toc.on('click', toggleToc); $mask.on('click', toggleToc); $('.navbar-main .catalogue').on('click', toggleToc); } }(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings));","link":"/js/main.js"}],"posts":[{"title":"23种设计模式","text":"创建型模式（5种）单例（Singleton）模式说明 单例类只有一个实例对象 该单例对象必须由单例类自行创建 单例类对外提供一个用于访问该单例的全局访问点 结构 单例类：包含一个实例且能自行创建这个实例的类 访问类：使用单例的类 实现 懒汉模式：首次获取时才创建单例1234567891011121314151617class LazySingleton { private static volatile Object obj; private LazySingleton() { } public static Object get() { if (obj == null) { synchronized (LazySingleton.class) { if (obj == null) { obj = new Object(); } } } return obj; }} 饿汉模式：类加载时就创建单例，首次获取前单例就已存在1234567891011121314class EagerSingleton { private static final Object OBJ; static { OBJ = new Object(); } private EagerSingleton() { } public static Object get() { return OBJ; }} 场景 只要求生成一个对象的场合 对象需要被共享的场合（配置对象、数据库连接池等） 频繁实例化又频繁销毁的场合（线程池、网络连接池等） 拓展 有限多例（Multitcm）模式：将单例替换为有限个实例 原型（Prototype）模式说明 以已创建的实例对象为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象（复制往往快于创建） 结构 抽象原型类：规定原型对象必须实现的接口（clone方法） 具体原型类：实现抽象原型类的接口（clone）方法，它是可复制的对象 访问类：使用接口（clone）方法来复制新对象 实现 实现Cloneable接口的clone方法（深克隆或浅克隆）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Entity implements Cloneable, Serializable { private String id; private Item item; public String getId() { return id; } public void setId(String id) { this.id = id; } public Item getItem() { return item; } public void setItem(Item item) { this.item = item; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } public Object deepClone() throws CloneNotSupportedException { Entity clone = (Entity) super.clone(); clone.item = (Item) this.item.clone(); return clone; } /** * 序列化方式实现深克隆 * @return * @throws IOException * @throws ClassNotFoundException */ public Object serialize() throws IOException, ClassNotFoundException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); byte[] bytes = bos.toByteArray(); ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); }}class Item implements Cloneable, Serializable { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); }} 场景 对象之间相似，仅几个属性不同的场景 对象创建过程比较复杂，但复制过程较为简单的场景 拓展 原型管理器模式：管理器中存储一系列原型，提过接口提供复制对象 工厂方法（Factory Method）模式抽象工厂（AbstractFactory）模式建造者（Builder）模式结构型模式（7种）代理（Proxy）模式适配器（Adapter）模式桥接（Bridge）模式装饰（Decorator）模式外观（Facade）模式享元（Flyweight）模式组合（Composite）模式行为型模式（11种）模板方法（TemplateMethod）模式策略（Strategy）模式命令（Command）模式职责链（Chain of Responsibility）模式状态（State）模式观察者（Observer）模式中介者（Mediator）模式迭代器（Iterator）模式访问者（Visitor）模式备忘录（Memento）模式解释器（Interpreter）模式 参考文档：http://c.biancheng.net/design_pattern/","link":"/2021/01/16/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"Kafka","text":"概述Apache Kafka 是一个开源分布式事件流平台。(Apache Kafka is an open-source distributed event streaming platform.) 事件流指从数据源中实时采集数据的行为,事件流可以用于确保数据的连续流动与解释 关键能力 发布（写）和订阅（读）事件流，包括从其他系统持续导入/导出数据 根据需求持久化存储 高时效性，当数据出现或回溯时及时处理(To process streams of events as they occur or retrospectively.) 工作模式通过TCP协议交互 说明 单例类只有一个实例对象 该单例对象必须由单例类自行创建 单例类对外提供一个用于访问该单例的全局访问点 结构 单例类：包含一个实例且能自行创建这个实例的类 访问类：使用单例的类 实现 懒汉模式：首次获取时才创建单例1234567891011121314151617class LazySingleton { private static volatile Object obj; private LazySingleton() { } public static Object get() { if (obj == null) { synchronized (LazySingleton.class) { if (obj == null) { obj = new Object(); } } } return obj; }} 饿汉模式：类加载时就创建单例，首次获取前单例就已存在1234567891011121314class EagerSingleton { private static final Object OBJ; static { OBJ = new Object(); } private EagerSingleton() { } public static Object get() { return OBJ; }} 场景 只要求生成一个对象的场合 对象需要被共享的场合（配置对象、数据库连接池等） 频繁实例化又频繁销毁的场合（线程池、网络连接池等） 拓展 有限多例（Multitcm）模式：将单例替换为有限个实例 原型（Prototype）模式说明 以已创建的实例对象为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象（复制往往快于创建） 结构 抽象原型类：规定原型对象必须实现的接口（clone方法） 具体原型类：实现抽象原型类的接口（clone）方法，它是可复制的对象 访问类：使用接口（clone）方法来复制新对象 实现 实现Cloneable接口的clone方法（深克隆或浅克隆）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Entity implements Cloneable, Serializable { private String id; private Item item; public String getId() { return id; } public void setId(String id) { this.id = id; } public Item getItem() { return item; } public void setItem(Item item) { this.item = item; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } public Object deepClone() throws CloneNotSupportedException { Entity clone = (Entity) super.clone(); clone.item = (Item) this.item.clone(); return clone; } /** * 序列化方式实现深克隆 * @return * @throws IOException * @throws ClassNotFoundException */ public Object serialize() throws IOException, ClassNotFoundException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); byte[] bytes = bos.toByteArray(); ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); }}class Item implements Cloneable, Serializable { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); }} 场景 对象之间相似，仅几个属性不同的场景 对象创建过程比较复杂，但复制过程较为简单的场景 拓展 原型管理器模式：管理器中存储一系列原型，提过接口提供复制对象 参考文档：https://kafka.apache.org/","link":"/2023/02/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E5%AF%B9/"},{"title":"设计模式概述","text":"什么是设计模式 设计模式是一套被反复使用、经过分类编目、代码设计经验的总结 其描述了软件开发过程中一些不断重复发生的问题，以及该问题的解决方案 是为了解决特定问题的一系列思路，具有一定普遍性，可反复使用 出现背景 1977年，建筑师 克里斯托夫·亚历山大（Christopher Alexander） 在其著作 《建筑模式语言：城镇、建筑、构造（A Pattern Language：Towns Building Construction）》 中所提出的253种关于城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1979年，在其另一部著作 《建筑的永恒之道（The Timeless way of building）》 中进一步强化了设计模式思想。 1987年， 肯特·贝克（Kent Beck） 和 沃德·坎宁安（Ward Cunningham） 首次将模式思想应用到Smalltalk中图形用户接口生成中，但未引起关注 1990年，软件工程届开始讨论设计模式相关话题，并展开多次研讨会 1995年， 艾瑞克·伽马（Erich Gamma） 、 理查德·海尔姆（Richard Helm） 、 拉尔夫·约翰森（Ralph Johnson） 、 约翰·威利斯迪斯（John Vlissides） 等4位作者 （Gang of Four，GoF） 合作出版了 《设计模式：可复用面向对象软件基础（Design Patterns：Elements of Reusable Object-Oriented Software）》 ，其中收录了23种设计模式，是软件设计模式的一大突破。直至今日，狭义设计模式所指的仍是上述23种设计模式 目的 提高代码的可重用性、可读性、可靠性 提示思维能力、编程能力、设计能力 代码结构标准化、提升开发效率、缩短开发周期 代码可重用性高、可读性好、可靠性高、灵活性好、可维护性强 基本要素 模式名称 通常用一两个词来描述，根据模式的问题、特点、解决方案、功能和效果来命名 问题 描述使用该模式的应用环境，解释设计问题和问题存在的前因后果，以及必须满足一系列先觉条件 解决方案 包括设计的组成部分、他们之间的相互关系以及各自的职责和协作方式。 解决方案不描述一个特定而具体的设计货实现，而是提供设计问题的抽象描述及怎样用一个具有一般意义的元素（类或对象）组合来解决问题 效果 描述该模式的应用效果及使用该模式所需要权衡的问题，即该模式的优缺点。 主要是对空间与时间的权衡，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题 显示的列出这些效果有主意理解与评价该设计模式 七大原则开闭原则（Open Close Principle，OCP）1988年， 勃兰特·梅耶（Bertrand Meyer） 在其著作 《面向对象软件构造（Object Oriented Software Construction）》 中提出: 软件应对拓展开放，对修改关闭Software entities should be open for extension, but closed for modification 作用 软件测试方面仅需测试拓展的代码，原代码仍能正常运行 提高代码的可复用性，代码粒度越小，复用性则越高 提高软件的可维护性，准守开闭原则的软件具有较高的稳定性和延续性，易于拓展和维护 实现 通过接口或抽象类为软件定义一个相对稳定的抽象层，将相同的可变因素封装在相同的实现类中 里氏替换原则（Liskov Substitution Principle，LSP）1987年， 里斯科夫（Liskov） 女士在 面向对象的技术高峰会议（OOPSLA） 上发表的一篇文章 《数据抽象和层次（Data Abstraction and Hierarchy）》 中提出: 继承必须确保超类所拥有的性质在子类中仍然成立。Inheritance should ensure that any property proved about supertype objects also holds for subtype objects. 作用 对开闭原则的补充 确保动作的正确性，即类的拓展不会给已有的系统引入新的错误，提高系统的稳定性 实现 子类继承父类时，除添加新功能实现拓展方法外，不能改变父类原油功能，即应尽量不重写（或禁止重写）父类方式 依赖倒置原则（Dependence Inversion Principle，DIP）1996年，Object Mentor 公司总裁 罗伯特·C.马丁（Rebert C.Martin） 在 C++ Report 发表文章，对其作出定义: 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 即：面向接口（抽象）编程 作用 实现开闭原则的重要途径之一 降低了模块之间的耦合 提高系统稳定性 减少并行开发引发的风险 提高代码可读性和可维护性 实现 通过面向接口编程降低耦合性 每个类尽量提供接口和抽象类，或二者都提供 变量的声明应尽量是接口或抽象类 任何类都不应该从具体类派生 使用继承时尽量准守里氏替换原则 单一职责原则（Dependence Inversion Principle，DIP）罗伯特·C.马丁（Rebert C.Martin） 在 《敏捷软件开发：原则、模式和实践》 中提出: 一个类应该有且仅有一个引起其变化的原因，否则类应该被拆分。There should never be more then one reason for a class to change. 作用 控制类的粒度，解耦对象、提高内聚 降低类的复杂度 提高类的可读性 提高系统的可维护性 由变更而引起的风险降低 实现 （简单但难运用）需要设计人员发现类的不同职责并将其分离，再封装到不同类或模块中 接口隔离原则（Interface Segregation Principle，ISP）2002年， 罗伯特·C.马丁（Rebert C.Martin） 给其定义: 客户端不应被迫依赖于它不使用的方法。Clients should not be forced to depend on methods they do not sure. 该原则还有另外一个定义： 一个类对另一个类的依赖应该建立在最小接口上。The dependency of one class to another one should depend on the smallest possible interface. 总结为：应为各个类建立专用的接口，不应建立一个庞大的接口供所有的依赖类调用 作用 约束接口，降低类对接口的依赖性 将庞大接口划分为多个粒度小的接口，预防外来变更的扩散，提高系统的灵活性和可维护性 提高系统内聚性，降低耦合性 接口粒度大小合理情况下可以保证系统的稳定性；但若粒度过小，造成接口过多将使设计复杂化；相对的粒度过大，灵活性降低，无法提供定制服务，给项目留下风险隐患 使用多个专门的接口可以体现对象的层次，可以通过接口的继承，实现对总接口的定义 减少项目中的冗余代码，避免派生类去实现无用的接口方法 实现 接口尽量小，但有限度，一个接口仅服务于一个子模块或业务逻辑 为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法 根据业务逻辑、环境因素进行接口拆分 使用最少的接口完成最多的事情 迪米特法则（Law of Demeter，LoD）又称为 最少知识原则（Least Knowledge Principle，LKP） ，1987年，诞生于 美国东北大学（Northeastern University） 的 迪米特（Demeter） 研究项目，由 伊恩·荷兰（Lan Holland） 提出，被UML创始者之一的 布奇（Booch） 普及，后来因 《程序员的修炼之道（The Pragmatic programmer）》 提及而广为人知，其定义为： 只与你的直接朋友交谈，不和陌生人说话。Talk only to your immediate friends and not to strangers. 可理解为：如果两个模块间无需直接通信，那么就不应当发生直接调用，可有第三方模块转发，以降低耦合性，提高独立性 作用 限制了软件实体间通信的宽度和深度 降低耦合性，提高独立性 提高类的可复用性和系统的拓展性 实现 依赖者只依赖应该依赖的对象 提供者只暴露应该暴露的方法 类的划分上，应创建弱耦合类 类结构上，降低类成员的访问权限 类设计上，优先考虑一个类设置成一个不变类 对类的引用上，因对其他对象的引用次数降至最低 不暴露类的属性，提供访问器 谨慎使用序列化（Serializable）功能 合成复用原则（Composite Reuse Principle，CRP）又叫 组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP） ，其要求在软件复用时，优先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现，使用继承关系需要严格遵守里氏替换原则，二者相辅相成，皆为开闭原则的具体实现规范 作用（继承复用的缺陷 组合/聚合维持类的封装性，又称为黑箱复用 新旧类耦合度低，该复用方式依赖较低，反问成分对象的唯一方法是通过成分对象的接口 灵活性高，可动态引用成分对象类型相同的对象 实现 通过将已有对象纳入新对象中，作为成员对象来实现。新对象可以调用成员对象的功能，从而达到复用的目的 参考文档：http://c.biancheng.net/design_pattern/","link":"/2021/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"消息中间件","slug":"消息中间件","link":"/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"}],"categories":[{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"异步处理, 分布式","slug":"异步处理-分布式","link":"/categories/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-%E5%88%86%E5%B8%83%E5%BC%8F/"}]}